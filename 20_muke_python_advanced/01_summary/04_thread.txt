线程?
	1）线程是操作系统进行运行调度的最小单位
           进程是系统进行资源分配和调度的基本单位
        2）线程用来提高程序并发的执行的程度。
           线程是操作系统直接运行和调度的，是进程中实际工作的单位，所以"进程的五状态模型"，其实是线程的五状态模型。
	3）一个进程可以并发多个线程，每个线程执行不同的任务
	4）在同一个进程下执行，并共享相同的上下文
	   一个进程中的各个线程与主线程共享同一片数据空间
           线程包括开始、执行顺序何结束三部分
           它可以被抢占（中断）和临时挂起（也称为睡眠）让步

	5）操作系统内核管理进程的数据结构，进程控制块PCB
	6）操作系统管理的数据结果，线程控制块TCB
----------------------------------------------------------------------------------------------------------------------------------------------------------

线程vs进程？
	1）对于资源，一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源
	2）在创建或撤销进程时，系统都要为之创建和回收进程控制块，分配或回收资源，如内存空间和I/O设备等，操作系统所付出的开销明显大于线程创建或撤销时的开销
	3）在进程切换时，涉及到当前进程CPU环境的保存以及被调度运行进程的CPU环境的设置，二线程的切换则需保存和设置少量寄存器内容，不设计存储器管理方面的操作，所以就切换代价而言，进程也是远高于线程的
	4）由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预
	5）并发性：不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量


a）内核支持线程(KST): 一对一，线程的一些列创建、撤销都在内核态完成，切换资源高，但是一个线程做IO,阻塞的时候，内核自动切换，但是用户级线程不会。
	1）线程的创建、撤销、以及要求由系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程的切换同样是在内核的支持下实现的，是与内核紧密相关的。

这种线程实现方式主要有什么优点？
	2）在多处理器系统中，内核能够同时调度同一进程中多个线程并行执行;如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程占有处理器运行，也可以运行其他进程中的线程;内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。

内核支持线程的主要缺点?
	3）对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行，这是因为用户进程的线程在用户态运行,而线程调度和管理在内核实现的，系统开销较大。
	系统开销体现在线程创建、撤销、切换、线程间的同步通信等等，都需要和操作系统内核进行交互（上下文切换）
	4）这个用户线程和操作系统的线程是一对一的,线程创建调度撤销都是操作系统实现


b）用户级线程(ULT): 由用户自行调度，内核无法干涉，内核线程阻塞，所有线程无法运行。
	1）用户级线程仅存在于用户空间中，对于这种线程的创建、撤销、线程之间的同步与通信等功能，都无须利用系统调用来实现，这种线程是与内核无关的
	2）对于用户级线程的切换，通常发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和切换的规则简单，因而使线程的切换速度特别快，因此我们可以为一个应用程序建立多个用户级线程。在一个系统中的用户级线程的数目可以达到数百个至数千个。
	3）内核是完全不知道用户级线程的存在的，所以，对于这种用户级线程，创建一个，或者销毁一个，都不需要告诉操作系统内核。

那么如果用户态线程需要从一个线程切换到另一个线程呢？
	4）那么只需要把一个用户态线程的数据，拷贝出来，把另一个线程的用户态数据放进去，然后再告诉内核态，运行数据更变，按照新的数据或者逻辑去跑。对于内核来说，他本身自己所需要进行的数据，是没有改变的，只用从用户态过来的那些数据需要改变。从内核的角度来说，运行的线程没有改变，只是需要进行的逻辑改变了一些，因为用户态线程传递过来的数据改变了。而从用户态过来的那些数据需要改变。从内核的角度来说，运行的线程没有改变，只是需要运行的逻辑改变了一些，因为用户态线程传递过来的数据改变了，而从用户态看来，我的线程已经切换成功了。从模型上看来，是多对一的关系。

用户级线程的主要缺点是：多对一
	5）因为用户及线程，操作系统是没感知的，即使用户级线程有多个，在操作系统看来只有一个
所以这也带来几个问题：
	6）ULT由用户程序自行调度，内核无法干涉
	7）内核线程的阻塞会导致所有的ULT线程都无法运行，读写文件系统调用，如果有4个用户线程，对应一个内核线程，一个用户线程读写需要切换到内核态，这个内核线程阻塞其他的3个用户线程都阻塞

----------------------------------------------------------------------------------------------------------------------------------------
c）组合方式线程：多对一
	1）结合上面的两种优点，避免了两种的缺点


常见语言的编程模型
	c/c++ 使用的原生操作系统thread 一对一
	java 使用的原生操作系统thread 一对一 Thread Runnable对象 JVM封装了操作系统thread
	javascript 单线程 async await yield等协程关键字来实现用户级线程
	golang 组合方式 GPM模型 G用户态的线程 M内核态的线程 P用来组合方式 用来协调
	python 组合方式 提供Thread线程对象 yield await async等关键字 asyncio等协程库
