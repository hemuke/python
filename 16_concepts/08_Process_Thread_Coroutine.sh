爬虫应用
1）线程1 解析链接
2）线程2 爬取图片
3）线程3 爬取文字
4）线程4 代理IP地址 解析

WEB应用
1）多用户同时访问web服务
2）一个用户开一个线程

电商秒杀，抢购活动
1）可以队列 排队实现业务

物联网传感器监控服务器
1）线程1 烟感器
2）线程2 温度传感器
3）线程3 湿度传感器

--------------------------------------------------------------------------------------------
线程 vs 进程 vs 协程
一个进程里面有一个及以上线程
协程都在一个线程里面的

进程线程的切换由系统控制，协程切换由自己控制。具体应用场景根据业务要求设置，一般IO密集型，即由大量读写请求的场景一般使用多线程或者多进程，CPU密集型，即需要大量计算的一般使用多进程，强调非阻塞异步并发的一般都是使用协程，有时候也是需要多进程线程池结合的，或者是其他组合方式。

协程和异步区别
1）在执行A函数的时候，可以随时中断，去执行B函数，然后中断B函数继续执行A函数（可以自动切换）
2）会执行其他的协程
3）异步是指多任务， 多个任务之间执行没有先后顺序，可以同时运行，执行的先后顺序不会有什么影响，而协程是在执行A函数的时候中断去执行B函数，中断B函数再继续执行A函数。
--------------------------------------------------------------------------------------------
进程是一个执行中的程序
1）每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据
2）操作系统管理其上所有进程的执行，并为这些进程合理地分配时间
3）进程也可通过派生(fork/spawn)新的进程来执行其他任务
线程
1）在同一个进程下执行，并共享相同的上下文
2）一个进程中的各个线程与主线程共享同一片数据空间
3）线程包括开始、执行顺序和结束三部分
4）它可以被抢占（中断）和临时挂起（也称为睡眠）————让步
协程
1）进程之间相互独立，可实现并行，但线程不可以，多线程只能并发执行，实际还是顺序执行，只是在同一时间片段，假似同时执行，cpu可以按时间切片执行，单核cpu同一个时刻只支持一个线程执行任务，多线程并发事实上就是多个线程排队申请调用cpu，cpu处理任务速度非常快，所以看上去多个线程任务说并发处理。
2）协程本身是个单线程，协程需要用户自己进行手动切换——当某线程在执行任务中的函数A（协程A）时，可任意中断，手动切换到任务中的另一个函数B（协程B），然后在适当的时候在回到函数A（协程A）中继续执行，这样虽然繁琐，但提供了更大的操作自由度，同时协程A和协程B都属于同一线程，切换效率相比于线程或进程间的切换有极大地优势。一个cpu支持上万的协程都没有问题，适合用于高并发处理。https://www.imooc.com/article/268517

--------------------------------------------------------------------------------------------
GIL 全局解析器锁
Python代码是通过Python解析器来执行的。通常使用Python解释器官方CPython。Cpython中有一个GIL，其作用相当于Lock,任何线程在执行前必须先获得GIL，一个线程在获得GIL后其他线程就不能执行，直到线程释放GIL。因此，GIL保证了同一时刻只有一个线程可以执行，从而导致Python中的多线程不能实现并行。
1）单核CPU系统中，不存在并行
2）多核CPU系统中，存在并行
3）GIL只是强制在任何时候只有一个线程可以执行Python代码，可以通过换CPython,第三方库c/c++来实现
4）I/O密集型应用与CPU密集型应用
I）对于IO密集型的任务，例如：网络请求、读写磁盘等，因为IO的速度远远低于CPU和内存的速度，所以，绝大部分时间都在等待IO操作的完成，CPU的消耗很少。因此，IO密集型的任务在使用多线程时，GIL无法利用多核的劣势体现得非常微弱。一个线程在进行IO操作之前，其获得的GIL总是会被释放，以允许其它线程在该线程等待IO操作的时候获得GIL。
II）对于计算密集型的任务，例如：科学计算、视频处理等，主要消耗的是CPU的资源，全靠CPU的运算能力。因此，计算密集型的任务在使用多线程时，GIL无法利用多核的劣势体现得非常明显，此外，任务数越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。
III）CPU密集型代码(各种循环处理、计数等等)，在这种情况下，由于计算工作多，计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。
IV）IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。

GIL 执行顺序
1）设置 GIL
2）切换进一个线程去运行
3）执行下面操作之一：
    * 指定数量的字节码指令
    * 线程主动让出控制权(可以调用 time.sleep(0)来完成)
4）把线程设置回睡眠状态(切换出线程)
5）解锁GIL
6）重复上面的操作

"一个线程运行 Python ，而其他 N 个睡眠或者等待 I/O."，GIL是CPython中特有的全局解释器锁，它主要锁定Python线程的CPU执行资源。
由于GIL的存在，导致python的多线程比单线程还慢，主要原因是在单核的时候，同时只有一个线程在执行CPU，所以这个线程总是能获取到GIL。而换到多核的时候，同时会有多个线程在不同的CPU核心上执行，此时不同线程之间就需要竞争GIL，而GIL只能同时被一个线程申请到，所以会导致其它线程处于闲置状态【即使它已经拥有了CPU资源】。所以Python在多核CPU上的多线程始终只有单线程在跑程序。
多线程比较低效时，可用multiprocess库替代Thread库，即使用多进程而不是多线程，每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。

-----------------------------------------------------------------------------------------------
协程
协程就是协同多任务
协程在同一个进程或者在一个线程中执行
一个线程里面可以有多个协程
进程(协程)是由操作系统调度，协程是由程序自己调度
不需要锁机制
Python多进程+协程利用

Python3.5之前
使用生成器yield实现
"""
# 使用next会执行到下一个next
def count_down():
    """ 倒计时错误 """
    while n > 0:
        yield n
        n -= 1


if __name__ == '__main__':
    rest = count_down(5)
    print(next(rest))
    print(next(rest))
    print(next(rest))
    print(next(rest))
    print(next(rest))
"""


"""
# 协程间的通信
def yield_test():
    """ 实现协程函数 """
    while True:
        n = (yield)
        print(n)


if __name__ == '__main__':
    rest = yield_test()
    next(rest)
    rest.send('666') 

send()方法具有两种功能：
第一，传值，send()方法，将其携带的值传递给yield，注意，是传递给yield，而不是变量n,然后再将其赋值给变量n。
第二，send()方法具有和next()方法一样的功能，也就是说，传值完毕后，会接着上次执行的结果继续执行，直到遇到yield停止。
"""

Python3.5之后
使用async和await两个关键字
async
"""
# 定义特殊函数
async def async_d():
    pass
# 当被调用时，不执行里面的代码，而是返回一个协程对象
# 在事件循环中调度其执行前，协程对象不执行任何操作
"""

await
"""
# 等待协程执行完成
# 当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程，比如大量的写文件等操作等。
# asyncio模块
# get_event_loop()获得事件循环队列
# run_until_complete() 注册任务到队列
# 在事件循环中调度其执行前，协程对象不执行任何操作
# asyncio模块用于事件循环
"""
