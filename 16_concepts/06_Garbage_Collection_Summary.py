"""
# 垃圾回收机制
# 以引用计数为主，分代收集为辅

# 如果一个对象的引用数为0，Python虚拟机就会回收这个对象的内存

# 引用计数的缺陷是循环引用的问题

"""

"""
# 满足特定条件，自动启动垃圾回收

  # 当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数
    当两者的差值高于某个阈值时，垃圾回收才会启动
    查看阈值gc.get_threshold()
"""

import gc
print(gc.get_threshold())
# (700, 10, 10)
# 分代回收，Python将所有的对象分为0,1,2三代
# 所有的新建对象都是0代对象
# 当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象
# 10次0代的垃圾回收 就会有1次的1代的垃圾回收

"""
1、

Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

引用计数法的原理是每个对象维护一个ob_refcnt，用来记录当前对象被引用的次数，也就是来追踪到底有多少引用指向了这个对象。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。当引用计数为0时，该对象生命就结束了

2

阈值分析：

700即是垃圾回收启动的阈值；

每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收；

何为分代回收

　　Python将所有的对象分为0，1，2三代；

　　所有的新建对象都是0代对象；

　　当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。

 

 gc.set_threshold()  # 设置Python垃圾回收的阈值

比如提高第一代的扫描阈值（1000），对2代对象进行更频繁的扫描（5个1代就有一次2代）。

        import gc

        gc.set_threshold(1000, 10, 5)



3 分代回收是python会自动循环回收的过程，当满足0代对象阈值后会进行1代对象的回收，满足1代后则会回收2代。

python在创建对象之前，会创建一个链表，零代链表，只不过这个链表是空的。每当你创建一个对象，python便会将其加入到零代链表。

python隔代回收的核心：对链子上的那些明明没有被引用但引用计数却不是0的对象进行引用计数减去一，看看你是不是垃圾。如果被引用多次减去一之后仍不为零，那么会在0代链表当中继续被清理，直至引用计数为零。因为如果没有变量指向它，或者作为函数的参数，列表的元素等等，那么它就始终是0代链表中被清理的对象。当0代链表被清理达到一定次数时，会清理1代链表。1代链表被清理达到一定次数时，会清理2代链表。

因此清理的频率最高的是0代链表，其次是1代链表，再是2代链表。

死亡容器、存活容器：

删除第一步：对执行删除操作后的每个引用-1，当对象的引用为0，把他们都放到死亡容器内。把那些引用仍然大于0的放到存活容器内。

删除第二步：遍历存活容器，查看是否有的存活容器引用了死亡容器内的对象，如果有就把该对象(注意是对象，比如0x7f94bb602f80，不是对象的引用)从死亡容器内取出，放到存活容器内。
当对象都没有变量引用他们了，所以经过这一步骤，他们还是在死亡组。

标记删除第三部：将死亡组所有对象删除。
'""
